#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.3 on Tue Aug 24 22:54:32 2010
from __future__ import absolute_import

import operator

from twisted.python import log

import wx
import zope.interface
from lxml import etree
import cssutils
import os

from djirc import interfaces
from djirc.ui import common

CSS_FILE = os.path.join(common.DATA_DIR, 'style.css')
import pdb; pdb.set_trace()

def css_urlFetch(url):
    """Disable CSS URLs for now"""
    raise NotImplementedError("URL loading is forbidden")

def set_fontfamily_css(font, fontfamily):
    """Apply css `fontfamily` comma-delimited list to wx `font`"""
    for name in fontfamily.split(','):
        name = name.strip()
        
        if font.SetFaceName(name):
            return
    
    raise ValueError("No font family could be applied "
        "(searched for '%s')" % fontfamily)

def element2TextAttr(element):
    tag = element.tag
    attr = wx.TextAttr()
    font = attr.GetFont()
    if tag == 'b':
        
        font.SetWeight(wx.FONTWEIGHT_BOLD)
        font.SetFamily(wx.FONTFAMILY_DEFAULT) # fix a nonsense bug in wx
    else:
        font.SetWeight(wx.FONTWEIGHT_NORMAL)
        font.SetFamily(wx.FONTFAMILY_DEFAULT) # fix a nonsense bug in wx
    attr.SetFont(font)
    attr.SetFlags(wx.TEXT_ATTR_FONT_WEIGHT)
    
    if not font.IsOk():
        log.err("Font change failed for element: %s" %
            etree.tostring(element))
    
    return attr

def _verify_minimum_style(style):
    """Verify minimum required style rules exist"""
    # FIXME: doesn't need to all be defined at root, but all defined eventually
    props = ['color', 'background-color', 'font-family']
    problems = [prop for prop in props if prop not in style]
    
    if problems:
        raise ValueError("Missing styles: %s" % ', '.join(problems))

def _styles2dict(styles):
    """Create a `TextAttr` from a list of `cssutils.css.CSSStyleDeclaration`s
    
    """
    if len(styles) < 1:
        raise ValueError("must use at least one style")
    
    # root (body) style is required to set all the main things
    root = styles[0]
    style_d = {}
    
    
    def append(d, k, v):
        d.setdefault(k, []).append(v)
    
    def replace(d, k, v):
        d[k] = v
    
    for style in styles:
        for prop in style.getProperties():
            if prop.name == 'font-family':
                method = append
            else:
                method = replace
            
            if 'color' in prop.name: #todo: better method
                value = common.css_color_to_rgb(prop.value)
            else:
                value = prop.value
            
            method(style_d, prop.name, value)
    
    _verify_minimum_style(style_d)
    
    return style_d

def _dict2TextAttr(style):
    font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
    font_family = style.pop('font-family')
    for familyset in reversed(font_family):
        try:
            set_fontfamily_css(font, familyset)
        except ValueError:
            pass
        else:
            break
    else:
        raise ValueError("No font family found (%s)" % (font_family,))
    
    fgcol = style.pop('color')
    bgcol = style.pop('background-color')
    align = wx.TEXT_ALIGNMENT_DEFAULT
    
    # we're done custom styles.
    if style:
        # log.warn doesn't exist...
        log.err("Non-empty style! Remaining directives ignored: %s" % style)
    
    return wx.TextAttr(fgcol, bgcol, font, align)

def styles2TextAttr(styles):
    return _dict2TextAttr(_CSSStyle_list_to_dict(styles))
    

class WxUI(wx.Frame):
    zope.interface.implements(interfaces.IUserInterface)
    def __init__(self, *args, **kwds):
        self.current_view = None
        
        #styling support
        self.css_parser = cssutils.CSSParser()
        self.css_parser.setFetcher(css_urlFetch)
        self.stylesheet = self.css_parser.parseFile(CSS_FILE)
        
        # begin wxGlade: MainWindow.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.channel_splitter = wx.SplitterWindow(self, -1, style=wx.SP_3D|wx.SP_BORDER | wx.SP_LIVE_UPDATE)
        self.window_1_pane_2 = wx.Panel(self.channel_splitter, -1)
        self.channel_list = wx.TreeCtrl(self.channel_splitter, -1, style=wx.TR_HAS_BUTTONS|wx.TR_LINES_AT_ROOT|wx.TR_DEFAULT_STYLE|wx.SUNKEN_BORDER)
        self.input = wx.TextCtrl(self.window_1_pane_2, -1, "", style=wx.TE_PROCESS_ENTER|wx.TE_PROCESS_TAB)
    
        self.__set_properties()
        self.__do_layout()
    
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.channel_change, self.channel_list)
        self.Bind(wx.EVT_TEXT_ENTER, self.enter_message, self.input)
        # end wxGlade
        
        #self.current_network = self.channel_list.AddRoot('Freenode', -1, -1, None)
    
    def set_view(self, new):
        if self.current_view is not None:
            self.current_view.control.Hide()
        self.current_view = new
        self.current_view.control.Show()
    
    def add_network(self, name):
        root = self.channel_list.AddRoot(name)
        view = WxNetworkView(self, root, self._channel_ctrl())
        self.channel_list.GetItemData(root).SetData(view)
        if self.current_view is None:
            self._tab_change(view)
        return view
        
    def _channel_ctrl(self):
        """Create new (hidden) channel control"""
        control = wx.TextCtrl(self.window_1_pane_2, -1, "", style=wx.TE_MULTILINE|wx.TE_READONLY|wx.TE_RICH|wx.TE_AUTO_URL)
        control.Bind(wx.EVT_SET_FOCUS, self.chatlog_focus)
        control.Hide()
        
        def op(*args, **kwargs): print args, kwargs
        control.Paste = op
        
        return control
    
    def __set_properties(self):
        # begin wxGlade: MainWindow.__set_properties
        self.SetTitle("Test IRC Window")
        # end wxGlade
    
    def __do_chatlog_layout(self):
        if self.current_view is not None:
            self.sizer_1.Clear()
            self.sizer_1.Add(self.current_view.control, 1, wx.EXPAND, 0)
            self.sizer_1.Add(self.input, 0, wx.EXPAND, 0)
    
    def __do_layout(self):
        # begin wxGlade: MainWindow.__do_layout
        root_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_1 = sizer_1 = wx.BoxSizer(wx.VERTICAL)
        self.__do_chatlog_layout()
        self.window_1_pane_2.SetSizer(sizer_1)
        self.channel_splitter.SplitVertically(self.channel_list, self.window_1_pane_2)
        root_sizer.Add(self.channel_splitter, 1, wx.EXPAND, 0)
        self.SetSizer(root_sizer)
        root_sizer.Fit(self)
        
        self.root_sizer = root_sizer
        self.Layout()
        # end wxGlade
    
    def chatlog_focus(self, event):
        #print 'focus had'
        #self.input.SetFocus()
        self.current_view.control.SetCaret(None)
        #caret.Hide()
    
    def enter_message(self, event):
        # HACK: RELIES ON GLOBAL FACTORY
        input = self.input.GetValue()
        if input:
            self.input.SetValue('')
            self.factory.send_command(self.current_view.name, input)

    def channel_change(self, event): # wxGlade: MainWindow.<event_handler>
        item = event.GetItem()
        view = self.channel_list.GetItemData(item).GetData()
        
        self._tab_change(view)
    
    def _tab_change(self, view):
        self.set_view(view)
        
        self.__do_chatlog_layout()
        #self.sizer_1.FitInside(self)
        self.sizer_1.Layout()
    
# end of class MainWindow

def closable(func):
    def wrapped(self, *args, **kwargs):
        if self.closed:
            raise ValueError("%r is closed" % self)
        else:
            return func(self, *args, **kwargs)
    return wrapped

class WxTabView(object):
    zope.interface.implements(interfaces.IUITab)
    def __init__(self, name, control):
        self.name = name
        self.control = control
        self.closed = False
    
    @closable
    def receive_xml(self, element):
        start = self.control.GetLastPosition()
        self.control.AppendText(common.etree_tostring(element) + '\n')
        
        # starts[node] = start_of_element
        starts = {}
        ends = {}
        
        # we'll mark up in order of endpoints. It doesn't make a difference
        # (due to perfect nesting)
        pos = 0
        for node, seen in common.dfs(element):
            if not seen:
                starts[node] = pos + start
                pos += len(node.text or '')
            else:
                ends[node] = pos + start
                pos += len(node.tail or '')
                
        for node, start in sorted(starts.iteritems(), key=operator.itemgetter(1)):
            try:
                end = ends[node]
            except KeyError:
                log.err()
                continue
            
            attr = element2TextAttr(node)
            success = self.control.SetStyle(start, end, attr)
            if not success:
                log.err("SetStyle failed for element: %s" %
                    etree.tostring(node))
    
    @closable
    def close(self):
        self.closed = True

class WxNetworkView(WxTabView):
    zope.interface.implements(interfaces.IUINetwork)
    def __init__(self, ui, tree, control):
        super(WxNetworkView, self).__init__(None, control)
        self.ui = ui
        self.tree = tree
        self.tab_map = {}
    
    def _add_tab(self, tab_name):
        control = self.ui._channel_ctrl()
        view = WxTabView(tab_name, control)
        data = wx.TreeItemData(view)
        self.ui.channel_list.AppendItem(self.tree, tab_name, -1, -1, data)
        self.tab_map[tab_name] = view
        return view
    
    add_channel = add_convo = _add_tab


def create_metaclient(reactor, metaclient_factory):
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    frame_1 = WxUI(None, -1, "")
    app.SetTopWindow(frame_1)
    frame_1.Show()
    
    reactor.registerWxApp(app)
    
    return metaclient_factory(reactor, frame_1)


